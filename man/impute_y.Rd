% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute_y.R
\name{impute_y}
\alias{impute_y}
\title{Impute y}
\usage{
impute_y(
  model_formula,
  data_sample,
  data_out_of_sample,
  method = c("EBLUP", "MQ", "RF", "XGB"),
  type_model = "gaussian",
  tune_RF = FALSE,
  xgboost_params = list(CV_XGB = TRUE, nfolds = 5, nrounds = 50),
  ...
)
}
\arguments{
\item{model_formula}{Model formula.}

\item{data_sample}{Data from the sample.}

\item{data_out_of_sample}{Data from the remaining part of population.}

\item{method}{Estimation method, choose between: \code{EBLUP}, \code{MQ}, \code{RF}, \code{XGB}.}

\item{type_model}{Type of outcome.}

\item{tune_RF}{Tune parameters in random forest? Default = FALSE.}

\item{xgboost_params}{List with parameters to run xgboost:
\itemize{
\item CV_XGB - logical variable, use cross-validation for gradient boosting? Default: TRUE.
\item nfolds - number of folds in cross-validation, default: nfolds = 5.
\item nrounds - the max number of iterations, default: nrounds = 50.
}}

\item{...}{Additional parameters.}
}
\value{
List with following parameters:
\item{y_hat_out_of_sample}{imputed out of sample outcomes}
\item{y_hat_sample}{predicted sample data using fitted model}
\item{outcome_fit}{fitted model to impute the data}
\item{y_full_imputed}{original outcomes and imputed out of sample outcomes in one vector}
\item{group_sample}{group labels in the sample}
\item{group_out_of_sample}{group lables out of sample}
}
\description{
Impute missing values of y in the remaining part of population.
}
\examples{

m = 50
ni = rep(5, m)
Ni = rep(100, m)
N = sum(Ni)
n = sum(ni)

X <- generate_X(
 n = N,
 p = 1,
 covariance_norm = NULL,
 cov_type = "unif",
 seed = 1
)

X_outcome <- generate_X(
 n = N,
 p = 1,
 covariance_norm = NULL,
 cov_type = "lognorm",
 seed = 1
)

populations <- generate_pop(X, X_outcome,
coeffs = get_default_coeffs(),
errors_outcome = get_default_errors_outcome(),
rand_eff_outcome = get_default_rand_eff_outcome(),
rand_eff_p_score = get_default_rand_eff_p_score(),
regression_type = "continuous",
Ni_size  = 100,
m = 50,
no_sim = 1,
seed = 10)

samples <- generate_sample(populations, ni_size = 5,
                           sample_part = "sampled",
                           get_index = TRUE)

data_sample <- data.frame(samples[[1]]$samp_data)
index_sample <- samples[[1]]$index_s
data_out_of_sample <- populations[-index_sample, ]

model_formula = y ~ X1 + Xo1 + A + (1 + A||group)

impute_EBLUP <- impute_y(model_formula,
                         data_sample,
                         data_out_of_sample,
                         method = "EBLUP",
                         type_model = "gaussian")

impute_MQ <- impute_y(model_formula,
                      data_sample,
                      data_out_of_sample,
                      method = "MQ",
                      type_model = "continuous")

impute_RF <- impute_y(model_formula,
                      data_sample,
                      data_out_of_sample,
                      method = "RF",
                      tune_RF = TRUE,
                      xgboost_params = list(CV_XGB = TRUE,
                                            nfolds = 5,
                                            nrounds = 50))

impute_XGB <- impute_y(model_formula,
                       data_sample,
                       data_out_of_sample,
                       method = "XGB",
                       xgboost_params = list(CV_XGB = TRUE,
                                             nfolds = 5,
                                             nrounds = 50))


}
