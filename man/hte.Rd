% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hte.R
\name{hte}
\alias{hte}
\title{Heterogenous treatment effect}
\usage{
hte(
  type_hte = c("OR", "IPW", "NIPW", "AIPW"),
  data_sample,
  data_out_of_sample,
  params_p_score = list(model_formula = A ~ X1 + (1 | group), method = "EBLUP", tune_RF =
    FALSE, clust_RF = TRUE, xgboost_params = list(CV_XGB = TRUE, nfolds = 5, nrounds =
    50)),
  params_OR = list(model_formula = y ~ X1 + Xo1 + (1 | group), method = "EBLUP", tune_RF
    = FALSE, clust_RF = TRUE, xgboost_params = list(CV_XGB = TRUE, nfolds = 5, nrounds =
    50), type_model = "gaussian"),
  params_impute_y = list(model_formula = y ~ X1 + Xo1 + A + (1 + A || group), method =
    "EBLUP", tune_RF = FALSE, clust_RF = TRUE, xgboost_params = list(CV_XGB = TRUE,
    nfolds = 5, nrounds = 50), type_model = "gaussian"),
  params_bootstrap = list(boot_var = FALSE, n_boot = 100, boot_seed = 10, type_boot =
    "br1"),
  estimated_p_score = NULL,
  ...
)
}
\arguments{
\item{type_hte}{Type of estimation method, choose between: \code{OR}, \code{IPW},
\code{NIPW}, \code{AIPW}.}

\item{data_sample}{Data from the sample.}

\item{data_out_of_sample}{Data from the remaining part of population.}

\item{params_p_score}{List with parameters to fit propensity score:
\itemize{
\item model_formula - model formula,
\item method - estimation method, choose between: \code{EBLUP},
\code{MQ}, \code{RF}, \code{XGB},
\item tune_RF - tune random forest parameters,
\item clust_RF - add clustering to random forest,
\item xgboost_params - list of parameters to obtain predictions
using gradient boosting, default: \code{CV_XGB = TRUE},
\code{nfolds = 5}, \code{nrounds = 50}.
}}

\item{params_OR}{List with parameters to fit outcome regression model:
\itemize{
\item model_formula - model formula,
\item method - estimation method, choose between: \code{EBLUP},
\code{MQ}, \code{RF}, \code{XGB},
\item tune_RF - tune random forest parameters,
\item clust_RF - add clustering to random forest,
\item xgboost_params - list of parameters to obtain predictions
using gradient boosting, default: \code{CV_XGB = TRUE},
\code{nfolds = 5}, \code{nrounds = 50}.
\item type_model - type of outcome.
}}

\item{params_impute_y}{List with parameters to fit imputation model:
\itemize{
\item model_formula - model formula,
\item method - estimation method, choose between: \code{EBLUP},
\code{MQ}, \code{RF}, \code{XGB},
\item tune_RF - tune random forest parameters,
\item clust_RF - add clustering to random forest,
\item xgboost_params - list of parameters to obtain predictions
using gradient boosting, default: \code{CV_XGB = TRUE},
\code{nfolds = 5}, \code{nrounds = 50}.
\item type_model - type of outcome.
}}

\item{params_bootstrap}{List with parameters to obtain bootstrap variance:
\itemize{
\item boot_var = FALSE,
\item n_boot = 500,
\item boot_seed = 10,
}}

\item{estimated_p_score}{Vector of estimated propensity scores, default: \code{estimated_p_score = NULL}.}

\item{...}{Additional parameters}
}
\description{
Calculates heterogrenous treatment effects for subpopulations
}
\examples{

m = 50
ni = rep(10, m)
Ni = rep(200, m)
N = sum(Ni)
n = sum(ni)

X <- generate_X(
 n = N,
 p = 1,
 covariance_norm = NULL,
 cov_type = "unif",
 seed = 1
)

X_outcome <- generate_X(
 n = N,
 p = 1,
 covariance_norm = NULL,
 cov_type = "lognorm",
 seed = 1
)

populations <- generate_pop(X, X_outcome,
coeffs = get_default_coeffs(),
errors_outcome = get_default_errors_outcome(),
rand_eff_outcome = get_default_rand_eff_outcome(),
rand_eff_p_score = get_default_rand_eff_p_score(),
regression_type = "continuous",
Ni_size  = 200,
m = 50,
no_sim = 1,
seed = 10)

samples <- generate_sample(populations, ni_size = 10,
                           sample_part = "sampled",
                           get_index = TRUE)

data_sample <- data.frame(samples[[1]]$samp_data)
index_sample <- samples[[1]]$index_s
data_out_of_sample <- populations[-index_sample, ]

model_formula_OR = y ~ X1 + Xo1 + (1|group)


hte_OR <- hte(type_hte = "OR",
              data_sample,
              data_out_of_sample,
              params_OR = list(model_formula = y ~ X1 + Xo1 + (1|group),
                               method = "EBLUP",
                               type_model = "gaussian"))



}
